<!DOCTYPE html>
<html lang="es-MX">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portafolio Robótica Aplicada</title>
    <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
    <!-- Simple line icons-->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/simple-line-icons/2.5.5/css/simple-line-icons.min.css"
        rel="stylesheet" />
    <!-- Google fonts-->
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic"
        rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="../../../Recursos\Archivos\styles.css">
    <!--Background color-->
    <style>
        body {
            background-color: #2f3132;
        }
    </style>
    <!-- Prism CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
        rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css"
        rel="stylesheet" />

    <!-- Prism JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>


</head>

<body id="page-top">
    <!-- Navigation -->
    <a class="menu-toggle rounded" href="#"><i class="fas fa-bars"></i></a>
    <nav id="sidebar-wrapper">
        <ul class="sidebar-nav">
            <li class="sidebar-brand"><a>Menu</a></li>
            <li class="sidebar-nav-item"><a href="../../../../index.html#page-top">Inicio</a></li>
            <li class="sidebar-nav-item"><a href="../../../../index.html#about">Nosotros</a></li>
            <li class="sidebar-nav-item"><a href="../../../../index.html#portfolio">Portfolio</a></li>
            <li class="sidebar-nav-item"><a href="../../../../index.html#contact">Contacto</a></li>
        </ul>
    </nav>

    <!-- Header -->
    <header class="bg-dark py-5">
        <div class="container px-4 px-lg-5 my-5">
            <div class="text-center text-white">
                <h1 class="display-4 fw-bolder">Tarea 11</h1>
                <p class="lead fw-normal text-white-50 mb-0">Trayectorias de robots</p>
                <a class="btn btn-primary btn-xl" href="../../../teoria.html">Regresar a Teoría</a>
            </div>
        </div>
    </header>
    <!--Info-->
    <section class="py-5 text-white">
        <div class="container px-4 px-lg-5 my-5">
            <h3 class="text-secondary mb-0">Introducción</h3>
            <div class="row gx-4 gx-lg-5">
                <div class="col-lg-6">
                    <p>Se utiliza la librería de roboticstoolbox-python para el análisis.</p>
                    </p>
                    <a class="btn btn-primary btn-xl" href="../T10/assets/Trayectorias.pdf" target="_blank">
                        Descargar teoría PDF</a>
                </div>
                <div class="col-lg-6">
                    <img class="img-fluid" width="50%" height="auto"
                        src="https://media.springernature.com/lw685/springer-static/image/chp%3A10.1007%2F978-981-16-0550-5_103/MediaObjects/487800_1_En_103_Fig2_HTML.png"
                        alt="...">


                </div>
            </div>
        </div>
    </section>
    <!-- Events Section -->
    <section id="events" class="events section">
        <div class="container" data-aos="fade-up">
            <div class="row">
                <div class="d-flex align-items-stretch">
                    <div class="card col-md-12 d-flex align-items-stretch">
                        <div class="card-img">

                            <iframe id="pdfViewer" src="../T10/assets/Trayectorias.pdf" width="100%" height="800px"></iframe>
                        </div>
                        <div class="card-body">
                            <h5 class="card-title"><a href="">Trayectria de robot</a>
                            </h5>
                            <p class="fst-italic text-center"></p>
                            <p class="card-text"></p>
                        </div>
                    </div>
                </div>
                <div class="d-flex align-items-stretch" style="margin-top: 10%;">
                    <div class="card col-md-12 d-flex align-items-stretch">
                        <div class="card-img">

                            <iframe id="pdfViewer"
                                src="../T0/assets/Introduction to Robotics Craig 4th Edition Global Edition.pdf#page=186"
                                width="100%" height="800px"></iframe>
                        </div>
                        <div class="card-body">
                            <h5 class="card-title"><a href="">Trayectorias de robot teoria</a>
                            </h5>
                            <p class="fst-italic text-center"></p>
                            <p class="card-text"></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>
    <section class="py-5 text-white">
        <div class="container px-4 px-lg-5 my-5">
            <h3 class="text-secondary mb-0">Código de trayectorias para calcular el espacio de trabajo</h3>
            <div class="row gx-4 gx-lg-5">
                <div class="col-lg-12">
                    <pre class="line-numbers">
<code class="language-python">    import numpy as np
    import matplotlib.pyplot as plt
    
    # Función para calcular el espacio de trabajo (esfera con cono invertido)
    def calcular_espacio_trabajo(radio_max, apertura_cono, puntos=10000):
        # Generar puntos aleatorios dentro de una esfera
        puntos_3d = []
        for _ in range(puntos):
            # Generar coordenadas esféricas aleatorias
            r = radio_max * np.cbrt(np.random.rand())  # Para que la distribución sea uniforme
            theta = np.random.uniform(0, 2 * np.pi)
            phi = np.random.uniform(0, np.pi)
            
            # Convertir a coordenadas cartesianas
            x = r * np.sin(phi) * np.cos(theta)
            y = r * np.sin(phi) * np.sin(theta)
            z = r * np.cos(phi)
    
            # Comprobar si el punto está fuera del cono invertido
            angulo_cono = np.arctan2(np.sqrt(x**2 + y**2), -z)  # Ahora comprobamos el ángulo con respecto al eje Z negativo
            if angulo_cono > apertura_cono:
                puntos_3d.append((x, y, z))
        
        return np.array(puntos_3d)
    
    # Función para dibujar el cubo dentro de la esfera
    def dibujar_cubo(radio_max):
        # El cubo debe estar dentro de la esfera, y su diagonal debe ser <= al diámetro de la esfera
        lado_cubo = 2 * radio_max / np.sqrt(3)  # Calcular el lado del cubo
        puntos_cubo = []
    
        for x in np.linspace(-lado_cubo/2, lado_cubo/2, num=15):  # Añadir puntos intermedios para una mejor visualización
            for y in np.linspace(-lado_cubo/2, lado_cubo/2, num=15):
                for z in np.linspace(-lado_cubo/2, lado_cubo/2, num=15):
                    puntos_cubo.append((x, y, z))
    
        return np.array(puntos_cubo)
    
    # Función para filtrar los puntos dentro del cubo que son afectados por el cono
    def filtrar_puntos_por_cono(puntos_cubo, apertura_cono):
        puntos_filtrados = []
        for punto in puntos_cubo:
            x, y, z = punto
            angulo_cono = np.arctan2(np.sqrt(x**2 + y**2), -z)  # Ángulo con respecto al eje Z negativo
            if angulo_cono > apertura_cono:  # Solo conservar puntos fuera del cono
                puntos_filtrados.append((x, y, z))
        return np.array(puntos_filtrados)
    
    
    ########################################################################################
    #                           FUNCIONES DE PRUEBA
    ########################################################################################
    
    # Función para verificar si un punto es verde o azul
    def es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono):
        # El cubo debe estar dentro de la esfera, y su diagonal debe ser <= al diámetro de la esfera
        lado_cubo = 2 * radio_max / np.sqrt(3)  # Calcular el lado del cubo
        
        # Comprobación del cubo: El punto debe estar dentro de los límites del cubo
        dentro_del_cubo = abs(x) <= lado_cubo/2 and abs(y) <= lado_cubo/2 and abs(z) <= lado_cubo/2
        
        # Comprobación del cono: El punto debe estar fuera del cono (se calcula el ángulo)
        angulo_cono = np.arctan2(np.sqrt(x**2 + y**2), -z)  # Ángulo con respecto al eje Z negativo
        fuera_del_cono = angulo_cono > apertura_cono
    
        # Verificar si el punto es verde
        es_lineal = dentro_del_cubo and fuera_del_cono
        
        # Verificar si el punto es azul
        # El punto debe estar dentro de la esfera y fuera del cono
        distancia_al_origen = np.sqrt(x**2 + y**2 + z**2)
        es_articular = distancia_al_origen <= radio_max and fuera_del_cono
    
        return es_lineal, es_articular
    
    # Ejemplo de uso:
    x, y, z = 0.005, 0.004, 0.15  # Punto de ejemplo
    radio_max = 18/100  # Radio máximo de la esfera
    apertura_cono = np.deg2rad(60)  # Ángulo de apertura del cono
    
    print(radio_max, apertura_cono)
    
    # Verificar si el punto es verde o azul
    es_lineal, es_articular = es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono)
    print(f"¿Es el punto verde? {es_lineal}")
    print(f"¿Es el punto azul? {es_articular}")
    #Revisando WP10... (0.005, 0.004806308479691594, 0.151378186779085)
    
    ########################################################################################
    #                           PLOT DE ESPACIO DE TRABAJO
    ########################################################################################
    
    # Calcular puntos del espacio de trabajo
    puntos_trabajo = calcular_espacio_trabajo(radio_max, apertura_cono)
    
    # Dibujar el cubo dentro de la esfera
    puntos_cubo = dibujar_cubo(radio_max)
    
    # Filtrar puntos dentro del cubo que no sean afectados por el cono
    puntos_cubo_filtrados = filtrar_puntos_por_cono(puntos_cubo, apertura_cono)
    
    # Graficar el espacio de trabajo
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    
    # Graficar los puntos dentro del área de trabajo (esfera)
    ax.scatter(puntos_trabajo[:, 0], puntos_trabajo[:, 1], puntos_trabajo[:, 2], c='b', s=0.5, label="Espacio de trabajo")
    
    # Graficar los puntos del cubo (rojos)
    #ax.scatter(puntos_cubo[:, 0], puntos_cubo[:, 1], puntos_cubo[:, 2], c='r', s=50, label="Puntos del cubo")
    
    # Graficar los puntos verdes dentro del cubo, que están fuera del cono
    ax.scatter(puntos_cubo_filtrados[:, 0], puntos_cubo_filtrados[:, 1], puntos_cubo_filtrados[:, 2], c='g', s=20, label="Puntos afectados por el cono (dentro del cubo)")
    
    # Graficar punto de prueba como morado
    ax.scatter(x, y, z, c='m', s=50, label="Punto de prueba")
    
    # Configuración de la visualización
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_title("Espacio de trabajo con cubo y puntos afectados por el cono")
    
    # Mostrar gráfico
    ax.legend()
    plt.show()
    
    </code></pre>
                </div>
            </div>
        </div>
        <div class="container" data-aos="fade-up">
            <div class="row">
                <div class="d-flex justify-content-center align-items-center" style="margin-top: 20px;">
                    <div class="card col-md-12 d-flex align-items-stretch">
                        <div class="container">
                            <div class="row">
                                <div class="col-md-12">
                                    <div class="card">
                                        <video class="w-100" src="assets/worksapce.mp4" controls muted autoplay loop></video>
                                    </div>
                                </div>
                                <div class="card-body text-center mt-3 text-black">
                                    <h5 class="card-title"><a href="#">Espacio de trabajo</a></h5>
                                    <p class="fst-italic text-black">Se presenta el video de la simulación del espacio de trabajo.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container px-4 px-lg-5 my-5">
                <h3 class="text-secondary mb-0">Código de trayectoria circular</h3>
                <div class="row gx-4 gx-lg-5">
                    <div class="col-lg-12">
                        <pre class="line-numbers">
<code class="language-python"> #Para trayectoria de un círculo
    import numpy as np
    import time
    import matplotlib.pyplot as plt
    from spatialmath import SE3
    import roboticstoolbox as rtb
    from roboticstoolbox import jtraj, ctraj
    
    #---------------------------
    #    1. Definicion del robot
    #---------------------------
    a1 = 0.02
    a2 = 0.10
    a3 = 0.08
    
    name = "Robot_3ejes"
    robot = rtb.DHRobot(
        [
            rtb.RevoluteDH(alpha=-np.pi/2,  a=0,    d=a1,  offset=0,  qlim=(-np.deg2rad(360), np.deg2rad(360))),
            rtb.RevoluteDH(alpha=0,         a=a2,   d=0,   offset=0,  qlim=(-np.deg2rad(210), np.deg2rad(30))),
            rtb.RevoluteDH(alpha=0,         a=a3,   d=0,   offset=0,  qlim=(-np.deg2rad(170), np.deg2rad(170)))
        ],
        name=name
    )
    print("Robot details:")
    print(robot)
    
    '''
    ---------------------------
        2. Creacion de matriz de coordenadas para trayectoria
    ---------------------------
    '''
    # Inicializa el primer waypoint
    P = np.array([[0.001],                              # X
                  [0.001 * np.cos(np.deg2rad(0))],        # Y
                  [0.001 * np.sin(np.deg2rad(0)) + 0.10]])  # Z
    
    # Genera waypoints a lo largo de una circunferencia (179 puntos adicionales cada 2 grados)
    for i in range(179):
        new_col = np.array([0.001, 
                            0.001 * np.cos(np.deg2rad(i*2)), 
                            0.001 * np.sin(np.deg2rad(i*2)) + 0.10]).reshape(3, 1)
        P = np.concatenate((P, new_col), axis=1)
    
    #########################################
    #        Revisar espacio de trabajo
    #########################################
    # Función para verificar si un punto es verde o azul
    def es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono):
        # El cubo debe estar dentro de la esfera, y su diagonal debe ser <= al diámetro de la esfera
        lado_cubo = 2 * radio_max / np.sqrt(3)  # Calcular el lado del cubo
        
        # Comprobación del cubo: El punto debe estar dentro de los límites del cubo
        dentro_del_cubo = abs(x) <= lado_cubo/2 and abs(y) <= lado_cubo/2 and abs(z) <= lado_cubo/2
        
        # Comprobación del cono: El punto debe estar fuera del cono (se calcula el ángulo)
        angulo_cono = np.arctan2(np.sqrt(x**2 + y**2), -z)  # Ángulo con respecto al eje Z negativo
        fuera_del_cono = angulo_cono > apertura_cono
    
        # Verificar si el punto es verde
        es_lineal = dentro_del_cubo and fuera_del_cono
        
        # Verificar si el punto es azul
        # El punto debe estar dentro de la esfera y fuera del cono
        distancia_al_origen = np.sqrt(x**2 + y**2 + z**2)
        es_articular = distancia_al_origen <= radio_max and fuera_del_cono
    
        return es_lineal, es_articular
    
    # Revisar si los puntos de la trayectoria son lineales o articulados
    radio_max = a2+a3  # Radio máximo del robot
    apertura_cono = np.deg2rad(60)  # Ángulo de apertura del cono
    
    # Verificar si es lineal o articulado
    for i in range(P.shape[1]):
        x, y, z = P[:, i].flatten()  # Aplanar la columna para obtener x, y, z
        es_lineal, es_articular = es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono)
        print(f"WP{i+1}:lineal {es_lineal},articulado {es_articular}")
    
    
    # Matriz de rotacion para la orientacion
    R = np.array([[1, 0, 0],
                  [0, 1, 0],
                  [0, 0, 1]])
    
    # Se crea una lista de objetos SE3 para cada waypoint
    coordenadas = [SE3.Rt(R, [x, y, z]) for x, y, z in zip(P[0], P[1], P[2])]
    
    # print("\nCoordenadas en el espacio de trabajo:")
    # for i, pos in enumerate(coordenadas):
    #     print(f"WP{i+1}: {pos}")
    
    '''
    ---------------------------
        3. Resolver la Cinematica inversa de cada coordenada
    ---------------------------
    '''
    #region
    q_sol = []                           
    q_actual = np.zeros(robot.n)         
    ik_init = time.time()
    
    for i, pos in enumerate(coordenadas):
        sol = robot.ikine_LM(pos, q0=q_actual, mask=(1,1,1,0,0,0))
        if sol.success:
            q_sol.append(sol.q)
            q_actual = sol.q
            print(f"IK para coord{i+1} resuelta: {sol.q}")
        else:
            print(f"IK fallo para coord: {i+1}")
    
    ik_end = time.time()
    print("\nTiempo total de calculo de IK: {:.4f} segs".format(ik_end - ik_init))
    #endregion
    '''
    ---------------------------
        4. Generar la trayectoria para movimiento por articulacion
    ---------------------------
    '''
    #region
    tray_segments = []  # Lista de posiciones
    vel_segments = []   # Lista de velocidades
    acc_segments = []   # Lista de aceleraciones
    T_segment = 1       # Duracion de cada segmento en segs
    n_points = 5       # Numero de puntos por segmento
    
    # Generar trayectorias entre cada par de configuraciones
    for i in range(len(q_sol) - 1):
        t_segment = np.linspace(0, T_segment, n_points)
        traj_seg = jtraj(q_sol[i], q_sol[i+1], t_segment)
        tray_segments.append(traj_seg.q)
        vel_segments.append(traj_seg.qd)
        acc_segments.append(traj_seg.qdd)
    
    # Trayectoria de regreso al punto inicial
    t_segment = np.linspace(0, T_segment, n_points)
    traj_return = jtraj(q_sol[-1], q_sol[0], t_segment)
    tray_segments.append(traj_return.q)
    vel_segments.append(traj_return.qd)
    acc_segments.append(traj_return.qdd)
    
    # Apilar los segmentos en una trayectoria completa
    q_traj  = np.vstack(tray_segments)
    qd_traj = np.vstack(vel_segments)
    qdd_traj = np.vstack(acc_segments)
    #endregion
    '''
    ---------------------------
        5. Evaluamos la trayectoria generada usando FK
    ---------------------------
    '''
    #region
    task_traj = []
    for q in q_traj:
        T_fk = robot.fkine(q)
        task_traj.append(T_fk.t)
    task_traj = np.array(task_traj)
    P_closed = np.hstack((P, P[:, 0:1]))
    #endregion
    '''
    ---------------------------
        6. Graficar Trayectorias y Angulos de Articulacion
    ---------------------------
    '''
    #region
    # Plot de la trayectoria en el espacio
    traj_fig = plt.figure("Trayectorias")
    ax = traj_fig.add_subplot(111, projection='3d')
    ax.plot(task_traj[:, 0], task_traj[:, 1], task_traj[:, 2],
            'b-', label='Trayectoria J')
    ax.plot(P_closed[0], P_closed[1], P_closed[2],
            'r:', linewidth=2, label='Trayectoria Ideal')
    ax.scatter(P[0], P[1], P[2],
               color='red', marker='o', s=50, label='Coordenadas')
    # for i in range(P.shape[1]):
    #     ax.text(P[0, i], P[1, i], P[2, i], f' WP{i+1}', color='black', fontsize=12)
    ax.set_title('Trayectoria Espacio Articular')
    ax.set_xlabel('X [m]')
    ax.set_ylabel('Y [m]')
    ax.set_zlabel('Z [m]')
    ax.legend()
    #endregion
    '''
    ---------------------------
        7. Graficar Posicione, Velocidades y Aceleraciones
    ---------------------------
    '''
    #region
    q_traj  = np.vstack(tray_segments)  # Posiciones
    qd_traj = np.vstack(vel_segments)    # Velocidad
    qdd_traj = np.vstack(acc_segments)   # Aceleraciones
    
    tiempo_total = len(tray_segments) * T_segment  
    eje_t = np.linspace(0, tiempo_total, q_traj.shape[0]) 
    
    fig_joint = plt.figure("Ángulo vs Tiempo")
    for i in range(q_traj.shape[1]):
        plt.plot(eje_t, q_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Ángulo (rad)")
    plt.title("Ángulo vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    
    fig_vel = plt.figure("Velocidades vs Tiempo")
    for i in range(qd_traj.shape[1]):
        plt.plot(eje_t, qd_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Velocidad (rad/s)")
    plt.title("Velocidades de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    fig_acc = plt.figure("Aceleraciones vs Tiempo")
    for i in range(qdd_traj.shape[1]):
        plt.plot(eje_t, qdd_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Aceleración (rad/s²)")
    plt.title("Aceleraciones de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    #endregion
    robot.plot(q_traj, block=False, loop=True)
    plt.show()    
        </code></pre>
                    </div>
                </div>

            </div>
        </div>
        <div class="container" data-aos="fade-up">
            <div class="row">
                <div class="d-flex justify-content-center align-items-center" style="margin-top: 20px;">
                    <div class="card col-md-12 d-flex align-items-stretch">
                        <div class="container">
                            <div class="row">
                                <div class="col-md-12">
                                    <div class="card">
                                        <video class="w-100" src="assets/Circulo.mp4" controls muted autoplay
                                            loop></video>
                                    </div>
                                </div>
                                <div class="card-body text-center mt-3 text-black">
                                    <h5 class="card-title"><a href="#">Trayectoria circular</a></h5>
                                    <p class="fst-italic text-black">Se presenta el video de la simulación de
                                        trayectoria circular.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
    </section>
    <div class="container px-4 px-lg-5 my-5">
        <h3 class="text-secondary mb-0">Código de trayectorias para trayectoria de un cubo</h3>
        <div class="row gx-4 gx-lg-5">
            <div class="col-lg-12">
                <pre class="line-numbers">
<code class="language-python"> import numpy as np
    import time
    import matplotlib.pyplot as plt
    from spatialmath import SE3
    import roboticstoolbox as rtb
    from roboticstoolbox import ctraj
    
    #---------------------------
    #    1. Definicion del robot
    #---------------------------
    a1 = 0.02
    a2 = 0.10
    a3 = 0.08
    
    name = "Robot_3ejes"
    robot = rtb.DHRobot(
        [
            rtb.RevoluteDH(alpha=-np.pi/2,  a=0,    d=a1,  offset=0,  qlim=(-np.deg2rad(360), np.deg2rad(360))),
            rtb.RevoluteDH(alpha=0,         a=a2,   d=0,   offset=0,  qlim=(-np.deg2rad(210), np.deg2rad(30))),
            rtb.RevoluteDH(alpha=0,         a=a3,   d=0,   offset=0,  qlim=(-np.deg2rad(170), np.deg2rad(170)))
        ],
        name=name
    )
    print("Robot details:")
    print(robot)
    
    '''
    ---------------------------
        2. Creacion de matriz de coordenadas para trayectoria
    ---------------------------
    '''
    # Definir las dimensiones del cubo
    lado_cubo = 2 * 0.1 / np.sqrt(3)  # Usando el radio maximo
    
    # Definir los vértices del cubo
    vertices_cubo = [
        [-lado_cubo / 2, -lado_cubo / 2, -lado_cubo / 2], # 1
        [lado_cubo / 2, -lado_cubo / 2, -lado_cubo / 2],  # 2
        [lado_cubo / 2, lado_cubo / 2, -lado_cubo / 2],   # 3
        [-lado_cubo / 2, lado_cubo / 2, -lado_cubo / 2],  # 4
        [-lado_cubo / 2, lado_cubo / 2, lado_cubo / 2],   # 5
        [lado_cubo / 2, lado_cubo / 2, lado_cubo / 2],    # 6
        [lado_cubo / 2, -lado_cubo / 2, lado_cubo / 2],   # 7
        [-lado_cubo / 2, -lado_cubo / 2, lado_cubo / 2],  # 8
        # Puntos para completar aristas del cubo
        [-lado_cubo / 2, lado_cubo / 2, lado_cubo / 2],   # 5
        [lado_cubo / 2, lado_cubo / 2, lado_cubo / 2],    # 6
        [lado_cubo / 2, lado_cubo / 2, -lado_cubo / 2],   # 3
        [-lado_cubo / 2, lado_cubo / 2, -lado_cubo / 2],  # 4
        [-lado_cubo / 2, -lado_cubo / 2, -lado_cubo / 2], # 1
        [-lado_cubo / 2, -lado_cubo / 2, lado_cubo / 2],  # 8
        [lado_cubo / 2, -lado_cubo / 2, lado_cubo / 2],   # 7
        [lado_cubo / 2, -lado_cubo / 2, -lado_cubo / 2]   # 2
    ]
    
    # Inicializar P con el primer vértice del cubo
    P = np.array(vertices_cubo[0]).reshape(3, 1)  # Primer punto del cubo
    
    # Concatenar los vértices restantes
    for v in vertices_cubo[1:]:  # Comienza desde el segundo vértice
        new_col = np.array(v).reshape(3, 1)  # Convertir a columna 3x1
        P = np.concatenate((P, new_col), axis=1)  # Concatenar en el eje 1 (columnas)
    
    #########################################
    #        Revisar espacio de trabajo
    #########################################
    # Función para verificar si un punto es verde o azul
    def es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono):
        # El cubo debe estar dentro de la esfera, y su diagonal debe ser <= al diámetro de la esfera
        lado_cubo = 2 * radio_max / np.sqrt(3)  # Calcular el lado del cubo
        
        # Comprobación del cubo: El punto debe estar dentro de los límites del cubo
        dentro_del_cubo = abs(x) <= lado_cubo/2 and abs(y) <= lado_cubo/2 and abs(z) <= lado_cubo/2
        
        # Comprobación del cono: El punto debe estar fuera del cono (se calcula el ángulo)
        angulo_cono = np.arctan2(np.sqrt(x**2 + y**2), -z)  # Ángulo con respecto al eje Z negativo
        fuera_del_cono = angulo_cono > apertura_cono
    
        # Verificar si el punto es verde
        es_lineal = dentro_del_cubo and fuera_del_cono
        
        # Verificar si el punto es azul
        # El punto debe estar dentro de la esfera y fuera del cono
        distancia_al_origen = np.sqrt(x**2 + y**2 + z**2)
        es_articular = distancia_al_origen <= radio_max and fuera_del_cono
    
        return es_lineal, es_articular
    
    # Revisar si los puntos de la trayectoria son lineales o articulados
    radio_max = a2+a3  # Radio máximo del robot
    apertura_cono = np.deg2rad(60)  # Ángulo de apertura del cono
    
    # Verificar si es lineal o articulado
    for i in range(P.shape[1]):
        x, y, z = P[:, i].flatten()  # Aplanar la columna para obtener x, y, z
        es_lineal, es_articular = es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono)
        print(f"WP{i+1}:lineal - {es_lineal}, articulado - {es_articular}")
    
    # Matriz de rotacion para la orientacion
    R = np.array([[1, 0, 0],
                  [0, 1, 0],
                  [0, 0, 1]])
    
    # Se crea una lista de objetos SE3 para cada waypoint
    coordenadas = [SE3.Rt(R, [x, y, z]) for x, y, z in zip(P[0], P[1], P[2])]
    
    print("\nCoordenadas en el espacio de trabajo:")
    for i, pos in enumerate(coordenadas):
        print(f"WP{i+1}: {pos}")
    
    '''
    ---------------------------
        3. Generar la trayectoria usando ctraj (trayectoria cartesiana)
    ---------------------------
    '''
    T_segment = 5      # Duracion conceptual de cada segmento en segundos
    n_points = 5       # Numero de puntos por segmento (cartesiano)
    q_traj_segments = []  # Lista para almacenar trayectorias en espacio articular
    q_current = np.zeros(robot.n)  # Condicion inicial para IK
    
    ik_start = time.time()
    
    # Para cada segmento entre waypoints consecutivos
    for i in range(len(coordenadas) - 1):
        cart_traj = ctraj(coordenadas[i], coordenadas[i+1], n_points)
        q_traj_seg = []  # Trayectoria articular para este segmento
        for pose in cart_traj:
            sol = robot.ikine_LM(pose, q0=q_current, mask=(1,1,1,0,0,0))
            if sol.success:
                q_traj_seg.append(sol.q)
                q_current = sol.q  # Actualiza q_current para la siguiente pose
            else:
                print(f"IK fallo en el segmento {i+1} para una pose intermedia")
        q_traj_segments.append(np.array(q_traj_seg))
    
    # Trayectoria de retorno: de la ultima pose al primer waypoint
    cart_traj = ctraj(coordenadas[-1], coordenadas[0], n_points)
    q_traj_seg = []
    for pose in cart_traj:
        sol = robot.ikine_LM(pose, q0=q_current, mask=(1,1,1,0,0,0))
        if sol.success:
            q_traj_seg.append(sol.q)
            q_current = sol.q
        else:
            print("IK fallo en el segmento de retorno para una pose intermedia")
    q_traj_segments.append(np.array(q_traj_seg))
    
    ik_end = time.time()
    print("\nTiempo total de calculo de IK: {:.4f} segs".format(ik_end - ik_start))
    
    # Concatena todas las trayectorias en una sola secuencia de configuraciones articulares
    q_traj = np.vstack(q_traj_segments)
    
    '''
    ---------------------------
        4. Evaluamos la trayectoria generada usando FK
    ---------------------------
    '''
    task_traj = []
    for q in q_traj:
        T_fk = robot.fkine(q)
        task_traj.append(T_fk.t)  # Extrae la traslacion de la pose
    task_traj = np.array(task_traj)
    
    # Para comparacion, se cierra la trayectoria ideal agregando el primer waypoint al final
    P_closed = np.hstack((P, P[:, 0:1]))
    
    '''
    ---------------------------
        5. Graficar Trayectorias, Ángulos, Velocidades y Aceleraciones
    ---------------------------
    '''
    # Plot de la trayectoria en el espacio de trabajo
    traj_fig = plt.figure("Trayectorias")
    ax = traj_fig.add_subplot(111, projection='3d')
    ax.plot(task_traj[:, 0], task_traj[:, 1], task_traj[:, 2],
            'b-', label='Trayectoria generada (IK)')
    ax.plot(P_closed[0], P_closed[1], P_closed[2],
            'r:', linewidth=2, label='Trayectoria Ideal')
    ax.scatter(P[0], P[1], P[2],
               color='red', marker='o', s=50, label='Coordenadas')
    # for i in range(P.shape[1]):
        # ax.text(P[0, i], P[1, i], P[2, i], f' WP{i+1}', color='black', fontsize=12)
    ax.set_title('Trayectoria en el Espacio de Trabajo')
    ax.set_xlabel('X [m]')
    ax.set_ylabel('Y [m]')
    ax.set_zlabel('Z [m]')
    ax.legend()
    ax.set_box_aspect([1, 1, 1])
    
    # Construir el vector de tiempo para la trayectoria completa.
    # Cada segmento se asume que dura T_segment segundos.
    num_segments = len(q_traj_segments)
    time_total = T_segment * num_segments
    t_vec = np.linspace(0, time_total, q_traj.shape[0])
    
    # Calcular velocidades y aceleraciones de las articulaciones usando diferencias finitas.
    qd_traj = np.gradient(q_traj, t_vec[1]-t_vec[0], axis=0)#Derivada de posi
    qdd_traj = np.gradient(qd_traj, t_vec[1]-t_vec[0], axis=0)#Derivada de vel
    
    # Plot de Ángulo de Articulaciones vs Tiempo
    fig_joint = plt.figure("Ángulo vs Tiempo")
    for i in range(q_traj.shape[1]):
        plt.plot(t_vec, q_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Ángulo (rad)")
    plt.title("Ángulo de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    # Plot de Velocidades de Articulaciones vs Tiempo
    fig_vel = plt.figure("Velocidades vs Tiempo")
    for i in range(qd_traj.shape[1]):
        plt.plot(t_vec, qd_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Velocidad (rad/s)")
    plt.title("Velocidades de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    # Plot de Aceleraciones de Articulaciones vs Tiempo
    fig_acc = plt.figure("Aceleraciones vs Tiempo")
    for i in range(qdd_traj.shape[1]):
        plt.plot(t_vec, qdd_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Aceleración (rad/s²)")
    plt.title("Aceleraciones de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    # Animacion del robot utilizando la trayectoria en espacio articular
    robot.plot(q_traj, block=False, loop=True)
    plt.show()
    </code></pre>
            </div>
        </div>

    </div>
    </div>
    <div class="container" data-aos="fade-up">
        <div class="row">
            <div class="d-flex justify-content-center align-items-center" style="margin-top: 20px;">
                <div class="card col-md-12 d-flex align-items-stretch">
                    <div class="container">
                        <div class="row">
                            <div class="col-md-12">
                                <div class="card">
                                    <video class="w-100" src="assets/Cubo.mp4" controls muted autoplay loop></video>
                                </div>
                            </div>
                            <div class="card-body text-center mt-3 text-black">
                                <h5 class="card-title"><a href="#">Trayectoria de un cubo</a></h5>
                                <p class="fst-italic text-black">Se presenta el video de la simulación para una trayectoria de un cubo.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="container px-4 px-lg-5 my-5">
            <h3 class="text-secondary mb-0">Código de trayectorias para una M</h3>
            <div class="row gx-4 gx-lg-5">
                <div class="col-lg-12">
                    <pre class="line-numbers">
<code class="language-python"> #Para trayectoria M
    #--------------------------- Calculo de puntos 3D ---------------------------
    # import matplotlib.pyplot as plt
    
    # offset_y = 0.03  # Desplazamiento en Y
    
    # vertices_3d_correctos = [
    #     (-0.06, offset_y, 0),       # punto inferior izquierdo
    #     (-0.05, offset_y, 0.075),   # punto superior izquierdo
    #     (0.00, offset_y, 0.05),     # punto medio izquierdo (ajustado)
    #     (0.05, offset_y, 0.075),    # punto medio derecho (ajustado)
    #     (0.06, offset_y, 0),        # punto inferior derecho
    # ]
    
    # # Descomponer las coordenadas en listas de X, Y y Z
    # x_coords_3d_correctos, y_coords_3d_correctos, z_coords_3d_correctos = zip(*vertices_3d_correctos)
    
    # # Crear el gráfico 3D
    # fig = plt.figure(figsize=(6, 6))
    # ax = fig.add_subplot(111, projection='3d')
    
    # # Graficar la letra M conectando los puntos
    # ax.plot(x_coords_3d_correctos + (x_coords_3d_correctos[0],), 
    #         y_coords_3d_correctos + (y_coords_3d_correctos[0],), 
    #         z_coords_3d_correctos + (z_coords_3d_correctos[0],), 'b-', marker='o')
    
    # # Etiquetas y configuración del gráfico
    # ax.set_title('Letra M corregida en un plano X,Z con offset de Y')
    # ax.set_xlabel('Eje X')
    # ax.set_ylabel('Eje Y')
    # ax.set_zlabel('Eje Z')
    # ax.set_xlim(-.1, .1)
    # ax.set_ylim(offset_y - 0.01, offset_y + 0.01)
    # ax.set_zlim(-.1, .1)
    
    # # Mostrar el gráfico
    # plt.show()
    
    #--------------------------- Calculo de puntos 3D ---------------------------
    
    import numpy as np
    import time
    import matplotlib.pyplot as plt
    from spatialmath import SE3
    import roboticstoolbox as rtb
    from roboticstoolbox import ctraj, jtraj
    
    #---------------------------
    #    1. Definicion del robot
    #---------------------------
    a1 = 0.02
    a2 = 0.10
    a3 = 0.08
    
    name = "Robot_3ejes"
    robot = rtb.DHRobot(
        [
            rtb.RevoluteDH(alpha=-np.pi/2,  a=0,    d=a1,  offset=0,  qlim=(-np.deg2rad(360), np.deg2rad(360))),
            rtb.RevoluteDH(alpha=0,         a=a2,   d=0,   offset=0,  qlim=(-np.deg2rad(210), np.deg2rad(30))),
            rtb.RevoluteDH(alpha=0,         a=a3,   d=0,   offset=0,  qlim=(-np.deg2rad(170), np.deg2rad(170)))
        ],
        name=name
    )
    print("Robot details:")
    print(robot)
    
    '''
    ---------------------------
        2. Creacion de matriz de coordenadas para trayectoria
    ---------------------------
    '''
    # Definir M
    offset_y = 0.05  # Desplazamiento en Y
    
    # Definir los vértices de la letra M
    # vertices_3d = [
    #     (-0.10, offset_y, 0),       # punto inferior izquierdo
    #     (-0.09, offset_y, 0.075),   # punto superior izquierdo
    #     (-0.06, offset_y, 0.05),     # punto medio izquierdo (ajustado)
    #     (-0.03, offset_y, 0.075),    # punto medio derecho (ajustado)
    #     (-0.02, offset_y, 0),        # punto inferior derecho
    # ]
    
    # vertices 3d pero ahora el plano es z 
    vertices_3d = [
        (-0.10, 0, offset_y),       # punto inferior izquierdo
        (-0.09, 0.075, offset_y),   # punto superior izquierdo
        (-0.06, 0.05, offset_y),     # punto medio izquierdo (ajustado)
        (-0.03, 0.075, offset_y),    # punto medio derecho (ajustado)
        (-0.02, 0, offset_y),        # punto inferior derecho
    ]
    
    
    # Inicializar P con el primer vértice del cubo
    P = np.array(vertices_3d[0]).reshape(3, 1)  # Primer punto del cubo
    
    # Concatenar los vértices restantes
    for v in vertices_3d[1:]:  # Comienza desde el segundo vértice
        new_col = np.array(v).reshape(3, 1)  # Convertir a columna 3x1
        P = np.concatenate((P, new_col), axis=1)  # Concatenar en el eje 1 (columnas)
    
    #########################################
    #        Revisar espacio de trabajo
    #########################################
    # Función para verificar si un punto es verde o azul
    def es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono):
        # El cubo debe estar dentro de la esfera, y su diagonal debe ser <= al diámetro de la esfera
        lado_cubo = 2 * radio_max / np.sqrt(3)  # Calcular el lado del cubo
        
        # Comprobación del cubo: El punto debe estar dentro de los límites del cubo
        dentro_del_cubo = abs(x) <= lado_cubo/2 and abs(y) <= lado_cubo/2 and abs(z) <= lado_cubo/2
        
        # Comprobación del cono: El punto debe estar fuera del cono (se calcula el ángulo)
        angulo_cono = np.arctan2(np.sqrt(x**2 + y**2), -z)  # Ángulo con respecto al eje Z negativo
        fuera_del_cono = angulo_cono > apertura_cono
    
        # Verificar si el punto es verde
        es_lineal = dentro_del_cubo and fuera_del_cono
        
        # Verificar si el punto es azul
        # El punto debe estar dentro de la esfera y fuera del cono
        distancia_al_origen = np.sqrt(x**2 + y**2 + z**2)
        es_articular = distancia_al_origen <= radio_max and fuera_del_cono
    
        return es_lineal, es_articular
    
    # Revisar si los puntos de la trayectoria son lineales o articulados
    radio_max = a2+a3  # Radio máximo del robot
    apertura_cono = np.deg2rad(60)  # Ángulo de apertura del cono
    
    # Verificar si es lineal o articulado
    for i in range(P.shape[1]):
        x, y, z = P[:, i].flatten()  # Aplanar la columna para obtener x, y, z
        es_lineal, es_articular = es_punto_lineal_o_articulado(x, y, z, radio_max, apertura_cono)
        print(f"WP{i+1}:lineal - {es_lineal}, articulado - {es_articular}")
    
    # Matriz de rotacion para la orientacion
    R = np.array([[1, 0, 0],
                  [0, 1, 0],
                  [0, 0, 1]])
    
    # Se crea una lista de objetos SE3 para cada waypoint
    coordenadas = [SE3.Rt(R, [x, y, z]) for x, y, z in zip(P[0], P[1], P[2])]
    
    print("\nCoordenadas en el espacio de trabajo:")
    for i, pos in enumerate(coordenadas):
        print(f"WP{i+1}: {pos}")
    
    '''
    ---------------------------
        3. Generar la trayectoria usando ctraj (trayectoria cartesiana)
    ---------------------------
    '''
    T_segment = 10      # Duracion conceptual de cada segmento en segundos
    n_points = 50       # Numero de puntos por segmento (cartesiano)
    q_traj_segments = []  # Lista para almacenar trayectorias en espacio articular
    q_current = np.zeros(robot.n)  # Condicion inicial para IK
    
    ik_start = time.time()
    
    # Para cada segmento entre waypoints consecutivos
    for i in range(len(coordenadas) - 1):
        cart_traj = ctraj(coordenadas[i], coordenadas[i+1], n_points)
        q_traj_seg = []  # Trayectoria articular para este segmento
        for pose in cart_traj:
            sol = robot.ikine_LM(pose, q0=q_current, mask=(1,1,1,0,0,0))
            if sol.success:
                q_traj_seg.append(sol.q)
                q_current = sol.q  # Actualiza q_current para la siguiente pose
            else:
                print(f"IK fallo en el segmento {i+1} para una pose intermedia")
        q_traj_segments.append(np.array(q_traj_seg))
    
    # ####################
    # Se realiza un movimiento por articulacion para cerrar la trayectoria
    # ####################
    
    # Trayectoria de retorno: de la ultima pose al primer waypoint
    # cart_traj = ctraj(coordenadas[-1], coordenadas[0], n_points)
    # q_traj_seg = []
    # for pose in cart_traj:
    #     sol = robot.ikine_LM(pose, q0=q_current, mask=(1,1,1,0,0,0))
    #     if sol.success:
    #         q_traj_seg.append(sol.q)
    #         q_current = sol.q
    #     else:
    #         print("IK fallo en el segmento de retorno para una pose intermedia")
    # q_traj_segments.append(np.array(q_traj_seg))
    
    # Trayectoria de retorno: de la ultima pose al primer waypoint por articulacion
    q_sol = []                           
    q_actual = np.zeros(robot.n)         
    ik_init = time.time()
    
    # Solo se realiza para el primer y ultimo punto
    sol = robot.ikine_LM(coordenadas[0], q0=q_current, mask=(1,1,1,0,0,0))
    if sol.success:
        q_sol.append(sol.q)
        q_current = sol.q
        print(f"IK para coord1 resuelta: {sol.q}")
    else:
        print(f"IK fallo para coord1")
    q_traj_segments.append(np.array(q_sol))
    
    sol = robot.ikine_LM(coordenadas[-1], q0=q_current, mask=(1,1,1,0,0,0))
    if sol.success:
        q_sol.append(sol.q)
        q_current = sol.q
        print(f"IK para coord2 resuelta: {sol.q}")
    else:
        print(f"IK fallo para coord2")
    
    q_traj_segments.append(np.array(q_sol))
    
    # tray_segments = []  # Lista de posiciones
    # vel_segments = []   # Lista de velocidades
    # acc_segments = []   # Lista de aceleraciones
    # T_segment = 1       # Duracion de cada segmento en segs
    # n_points = 5       # Numero de puntos por segmento
    
    # t_segment = np.linspace(0, T_segment, n_points)
    # traj_return = jtraj(q_sol[-1], q_sol[0], t_segment)
    # tray_segments.append(traj_return.q)
    # vel_segments.append(traj_return.qd)
    # acc_segments.append(traj_return.qdd)
    
    ik_end = time.time()
    print("\nTiempo total de calculo de IK: {:.4f} segs".format(ik_end - ik_start))
    
    # Concatena todas las trayectorias en una sola secuencia de configuraciones articulares
    q_traj = np.vstack(q_traj_segments)
    
    '''
    ---------------------------
        4. Evaluamos la trayectoria generada usando FK
    ---------------------------
    '''
    task_traj = []
    for q in q_traj:
        T_fk = robot.fkine(q)
        task_traj.append(T_fk.t)  # Extrae la traslacion de la pose
    task_traj = np.array(task_traj)
    
    # # Para comparacion, se cierra la trayectoria ideal agregando el primer waypoint al final
    P_closed = np.hstack((P, P[:, 0:1]))
    
    
    
    
    '''
    ---------------------------
        5. Graficar Trayectorias, Ángulos, Velocidades y Aceleraciones
    ---------------------------
    '''
    # Plot de la trayectoria en el espacio de trabajo
    traj_fig = plt.figure("Trayectorias")
    ax = traj_fig.add_subplot(111, projection='3d')
    ax.plot(task_traj[:, 0], task_traj[:, 1], task_traj[:, 2],
            'b-', label='Trayectoria generada (IK)')
    ax.plot(P_closed[0], P_closed[1], P_closed[2],
            'r:', linewidth=2, label='Trayectoria Ideal')
    ax.scatter(P[0], P[1], P[2],
               color='red', marker='o', s=50, label='Coordenadas')
    # for i in range(P.shape[1]):
        # ax.text(P[0, i], P[1, i], P[2, i], f' WP{i+1}', color='black', fontsize=12)
    ax.set_title('Trayectoria en el Espacio de Trabajo')
    ax.set_xlabel('X [m]')
    ax.set_ylabel('Y [m]')
    ax.set_zlabel('Z [m]')
    ax.legend()
    ax.set_box_aspect([1, 1, 1])
    
    # Construir el vector de tiempo para la trayectoria completa.
    # Cada segmento se asume que dura T_segment segundos.
    num_segments = len(q_traj_segments)
    time_total = T_segment * num_segments
    t_vec = np.linspace(0, time_total, q_traj.shape[0])
    
    # Calcular velocidades y aceleraciones de las articulaciones usando diferencias finitas.
    qd_traj = np.gradient(q_traj, t_vec[1]-t_vec[0], axis=0)#Derivada de posi
    qdd_traj = np.gradient(qd_traj, t_vec[1]-t_vec[0], axis=0)#Derivada de vel
    
    # Plot de Ángulo de Articulaciones vs Tiempo
    fig_joint = plt.figure("Ángulo vs Tiempo")
    for i in range(q_traj.shape[1]):
        plt.plot(t_vec, q_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Ángulo (rad)")
    plt.title("Ángulo de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    # Plot de Velocidades de Articulaciones vs Tiempo
    fig_vel = plt.figure("Velocidades vs Tiempo")
    for i in range(qd_traj.shape[1]):
        plt.plot(t_vec, qd_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Velocidad (rad/s)")
    plt.title("Velocidades de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    # Plot de Aceleraciones de Articulaciones vs Tiempo
    fig_acc = plt.figure("Aceleraciones vs Tiempo")
    for i in range(qdd_traj.shape[1]):
        plt.plot(t_vec, qdd_traj[:, i], label=f'J {i+1}')
    plt.xlabel("Tiempo (s)")
    plt.ylabel("Aceleración (rad/s²)")
    plt.title("Aceleraciones de Articulaciones vs Tiempo")
    plt.legend()
    plt.grid(True)
    
    # Animacion del robot utilizando la trayectoria en espacio articular
    #robot.plot(q_traj, block=False, loop=True)
    plt.show()
    
</code></pre>
                </div>
            </div>

        </div>
    </div>
    <div class="container" data-aos="fade-up">
        <div class="row">
            <div class="d-flex justify-content-center align-items-center" style="margin-top: 20px;">
                <div class="card col-md-12 d-flex align-items-stretch">
                    <div class="container">
                        <div class="row">
                            <div class="col-md-12">
                                <div class="card">
                                    <video class="w-100" src="assets/M.mp4" controls muted autoplay loop></video>
                                </div>
                            </div>
                            <div class="card-body text-center mt-3 text-black">
                                <h5 class="card-title"><a href="#">Trayectoria M</a></h5>
                                <p class="fst-italic text-black">Se presenta el video de la simulación para una
                                    trayectoria de M.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </section>



        <section class=" text-white">
            <div class="container mt-5">
                <h2 class="text-center mb-4">Referencias Bibliográficas</h2>
                <ul class="list-group">
                    <li class="list-group-item">
                        Niku, S. B. (2020). <i>Introduction to robotics: Analysis, control, applications</i>. John Wiley
                        and
                        Sons Ltd.
                    </li>
                    <li class="list-group-item">
                        Craig, J. J. (2018). <i>Introduction to robotics: Mechanics and control</i>. Pearson.
                    </li>
                    <li class="list-group-item">
                        D'Addario, M. (2016). <i>Manual de robótica industrial: Fundamentos, usos y aplicaciones</i>.
                        CreateSpace Independent Publishing Platform.
                    </li>
                </ul>
            </div>
        </section>


        <!-- Footer -->
        <footer class="footer text-center">
            <div class="container px-4 px-lg-5"></div>
            <ul class="list-inline mb-5">
                <li class="list-inline-item">
                    <a class="social-link rounded-circle text-white mr-3"
                        href="https://mx.linkedin.com/in/jos%C3%A9-pablo-hern%C3%A1ndez-alonso-03a195256"><i
                            class="icon-social-linkedin"></i></a>
                </li>
                <li class="list-inline-item">
                    <a class="social-link rounded-circle text-white mr-3"
                        href="https://www.instagram.com/jose_pablo_ha?igsh=MTlvb2s1ejFuY210MQ%3D%3D&utm_source=qr"><i
                            class="icon-social-instagram"></i></a>
                </li>
                <li class="list-inline-item">
                    <a class="social-link rounded-circle text-white" href="https://github.com/JPHAJP"><i
                            class="icon-social-github"></i></a>
                </li>
            </ul>
            <img src="../../../Recursos/Imagenes/IM3.png" alt="University Logo" style="width:100px;">
            <p>Universidad Iberoamericana Puebla.</p>
            <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/"><a property="dct:title"
                    rel="cc:attributionURL" href="https://jphajp.github.io/Robotica/">Portafolio Robótica Aplicada</a>
                by <a rel="cc:attributionURL dct:creator" property="cc:attributionName"
                    href="https://github.com/JPHAJP">José Pablo Hernández Alonso</a> is licensed under <a
                    href="https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank"
                    rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img
                        style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
                        src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img
                        style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
                        src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img
                        style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
                        src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt=""><img
                        style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
                        src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a></p>
    </div>
    </footer>

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top"><i class="fas fa-angle-up"></i></a>
    <!-- Bootstrap core JS-->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Core theme JS-->
    <script src="../../../Recursos\Archivos\scripts.js"></script>
    <!-- Prism.js script -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script> -->
    <!-- Prism.js plugin for line numbers -->
    <!-- <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/line-numbers/prism-line-numbers.min.js"></script> -->
    <!-- Prism.js plugin for toolbar -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/toolbar/prism-toolbar.min.js"></script> -->
    <!-- Prism.js plugin for copy to clipboard functionality -->
    <!-- <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script> -->
</body>

</html>